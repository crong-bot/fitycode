{"version":3,"sources":["generate.js","App.js","small.js","Editor.js","index.js","lexer.js"],"names":["tp","node","type","statements","map","d","join","varName","var_name","value","jsExpr","funName","fun_name","arg_list","arguments","arg","has_middle_condition","has_last_statement","first_condition","first_statement","middle_condition","i","middle_statement","last_statement","arrayname","array_name","array_value","a","b","statement","console","log","nearley","require","generate","default","App","useState","code","setCode","parser","Parser","Grammar","fromCompiled","grammar","logs","setLogs","consoleStyles","BASE_BACKGROUND_COLOR","BASE_FONT_SIZE","LOG_ERROR_BACKGROUND","LOG_WARN_BACKGROUND","LOG_INFO_BACKGROUND","CompileandExec","feed","parserResult","results","line","lines","concat","eval","useEffect","Hook","window","currLogs","Unhook","className","onClick","language","onChange","variant","filter","styles","id","x","mylexer","Lexer","ParserRules","name","symbols","postprocess","data","label","has","identifier","literal","eol","indent","undefined","dedent","has_last_condition","operator","v","string","iterator","calculator","number","ws","ParserStart","module","exports","Editor","props","onBeforeChange","editor","options","lint","lineNumbers","mode","lineWrapping","theme","ReactDOM","render","StrictMode","document","getElementById","indentifiedLexer","compile","nl","match","lineBreaks","comment","lparen","rparen","lbracke","rbracke","lbrace","rbrace","fatarrow","assign","keyword"],"mappings":"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","file":"static/js/main.059f1232.chunk.js","sourcesContent":["function generateJsForStatements(statements) {\n  const lines = [];\n  for (let statement of statements) {\n    const line = tp(statement);\n    lines.push(line);\n  }\n  return lines.join('\\n');\n}\nfunction tp(node) {\n  if (node.type === 'closure') {\n    return `${node.statements.map((d) => tp(d)).join('\\n')}`;\n  } else if (node.type === 'var_assign') {\n    const varName = node.var_name.value;\n    const jsExpr = tp(node.value);\n    const js = `var ${varName} = ${jsExpr}`;\n    return js;\n  } else if (node.type === 'fun_call') {\n    const funName = node.fun_name.value;\n    const arg_list = node.arguments\n      .map((arg) => {\n        return tp(arg);\n      })\n      .join(',');\n    return `${funName}(${arg_list})`;\n  } else if (node.type === 'ifstate') {\n    if (node.has_middle_condition && node.has_last_statement) {\n      return `if(${tp(node.first_condition)}) {\n      ${tp(...node.first_statement)}}\n      ${node.middle_condition\n        .map((d, i) => `else if(${tp(d)}) {${tp(...node.middle_statement[i])}}`)\n        .join('\\n')}\n      else {${tp(...node.last_statement)}}\n      `;\n    } else if (node.has_middle_condition && !node.has_last_statement) {\n      return `if(${tp(node.first_condition)}) {\n      ${tp(...node.first_statement)}}\n      ${node.middle_condition\n        .map((d, i) => `else if(${tp(d)}) {${tp(...node.middle_statement[i])}}`)\n        .join('\\n')}`;\n    } else if (!node.has_middle_condition && node.has_last_statement) {\n      return `if(${tp(node.first_condition)}) {\n      ${tp(...node.first_statement)}}\n      else {${tp(...node.last_statement)}}`;\n    } else {\n      return `if(${tp(node.first_condition)}) {\n      ${tp(...node.first_statement)}}`;\n    }\n  } else if (node.type === 'condition') {\n    return node.value.map((d) => tp(d)).join('');\n  } else if (node.type === 'array') {\n    const arrayname = node.array_name.value;\n    return `var ${arrayname}=[${node.array_value\n      .map((d) => {\n        return tp(d);\n      })\n      .join(',')}]`;\n  } else if (node.type === 'for_block') {\n    const a = node.a.value;\n    const b = node.b.value;\n    return `for (var ${a} in ${b}) {${tp(...node.statement)} };`;\n  } else if (node.type === 'return') {\n    return node.value;\n  } else if (node.type === 'operator') {\n    return node.value;\n  } else if (node.type === 'string') {\n    return node.value;\n  } else if (node.type === 'number') {\n    return node.value;\n  } else if (node.type === 'identifier') {\n    return node.value;\n  } else if (node.type === 'calculator') {\n    return node.value;\n  } else {\n    console.log('문법이 틀렸어요...');\n    /* throw new Error(`unhandled ast node type 11`); */\n  }\n}\n\nexport default tp;\n","import {default as grammar} from './small';\nimport Editor from './Editor.js';\nimport React, { useState, useEffect } from 'react';\nimport { Console, Hook, Unhook } from 'console-feed';\n\nconst nearley = require('nearley');\n/* const grammar = require('./small.js'); */\n\nconst generate = require('./generate.js').default;\n\nfunction App() {\n  const [code, setCode] = useState('');\n  /* const [a, setA] = useState(''); */\n  const parser = new nearley.Parser(nearley.Grammar.fromCompiled(grammar));\n  const [logs, setLogs] = useState([]);\n\n  const consoleStyles = {\n    BASE_BACKGROUND_COLOR: 'none',\n    BASE_FONT_SIZE: '1.2rem',\n    LOG_ERROR_BACKGROUND: 'rgba(255,0,0,.1)',\n    LOG_WARN_BACKGROUND: 'rgba(255,255,0,.1)',\n    LOG_INFO_BACKGROUND: 'rgba(0,0,255,.1)',\n  };\n\n  useEffect(() => {\n    Hook(\n      window.console,\n      (log) => setLogs((currLogs) => [...currLogs, log]),\n      false\n    );\n    return () => Unhook(window.console);\n  }, []);\n\n  function CompileandExec() {\n    parser.feed(code);\n    const parserResult = parser.results;\n    const line = generate(parserResult[0][0]);\n    const lines = line.concat(\n      '\\n',\n      `function 화면(...arg) {\n      console.log(...arg)\n    }`\n    );\n    eval(lines);\n    /*     setA(`<html>\n      <body\n      \n      </body>\n      <script>console.log(\"a\")</script>\n    </html>`); */\n  }\n\n  return (\n    <>\n      <div className=\"panel\">\n        <h1 className=\"title\"> fitycode PLAYGROUND</h1>\n        <div className=\"left_pane\">\n          <button className=\"run_btn\" onClick={CompileandExec}>\n            RUN\n          </button>\n          <Editor language=\"javascript\" value={code} onChange={setCode} />\n        </div>\n        <div className=\"right_pane\">\n          <Console\n            logs={logs}\n            variant=\"light\"\n            filter=\"Methods[log]\"\n            styles={consoleStyles}\n          />\n          {/*    <iframe\n            srcDoc={a}\n            title=\"output\"\n            frameBorder=\"0\"\n            sandbox=\"allow-scripts\"\n            width=\"100%\"\n            height=\"100%\"\n          /> */}\n        </div>\n      </div>\n    </>\n  );\n}\n\nexport default App;\n","/* eslint-disable no-undef */\n// Generated automatically by nearley, version 2.19.7\n// http://github.com/Hardmath123/nearley\n(function () {\n  function id(x) {\n    return x[0];\n  }\n\n  const mylexer = require('./lexer');\n  const wrapVariable = (name) => ({\n    label: 'atom',\n    type: 'variable',\n    value: name,\n  });\n  var grammar = {\n    Lexer: mylexer,\n    ParserRules: [\n      { name: 'statements', symbols: ['closure'], postprocess: id },\n      { name: 'closure$ebnf$1', symbols: [] },\n      {\n        name: 'closure$ebnf$1',\n        symbols: ['closure$ebnf$1', 'statement'],\n        postprocess: function arrpush(d) {\n          return d[0].concat([d[1]]);\n        },\n      },\n      {\n        name: 'closure',\n        symbols: ['closure$ebnf$1'],\n        postprocess: (data) => [\n          {\n            label: 'closure',\n            type: 'closure',\n            statements: data[0],\n          },\n        ],\n      },\n      { name: 'statement', symbols: ['var_assign', '_m'], postprocess: id },\n      { name: 'statement', symbols: ['fun_call', '_m'], postprocess: id },\n      { name: 'statement', symbols: ['if_state', '_m'], postprocess: id },\n      { name: 'statement', symbols: ['for_state', '_m'], postprocess: id },\n      { name: 'statement', symbols: ['return', '_m'], postprocess: id },\n      {\n        name: 'var_assign',\n        symbols: [\n          mylexer.has('identifier') ? { type: 'identifier' } : identifier,\n          '_',\n          { literal: '=' },\n          '_',\n          'expr',\n        ],\n        postprocess: (data) => {\n          return {\n            label: 'state',\n            type: 'var_assign',\n            var_name: data[0],\n            value: data[4],\n          };\n        },\n      },\n      {\n        name: 'var_assign',\n        symbols: [\n          mylexer.has('identifier') ? { type: 'identifier' } : identifier,\n          '_',\n          { literal: '=' },\n          '_',\n          'array',\n        ],\n        postprocess: (data) => {\n          return {\n            label: 'state',\n            type: 'array',\n            array_name: data[0],\n            array_value: data[4],\n          };\n        },\n      },\n      { name: 'fun_call$ebnf$1$subexpression$1', symbols: ['arg_list', '_'] },\n      {\n        name: 'fun_call$ebnf$1',\n        symbols: ['fun_call$ebnf$1$subexpression$1'],\n        postprocess: id,\n      },\n      {\n        name: 'fun_call$ebnf$1',\n        symbols: [],\n        postprocess: function (d) {\n          return null;\n        },\n      },\n      {\n        name: 'fun_call',\n        symbols: [\n          mylexer.has('identifier') ? { type: 'identifier' } : identifier,\n          '_',\n          { literal: '(' },\n          '_',\n          'fun_call$ebnf$1',\n          { literal: ')' },\n        ],\n        postprocess: (data) => {\n          return {\n            label: 'state',\n            type: 'fun_call',\n            fun_name: data[0],\n            arguments: data[4] ? data[4][0] : [],\n          };\n        },\n      },\n      {\n        name: 'if_state',\n        symbols: [\n          { literal: '만약' },\n          '_',\n          'condition',\n          mylexer.has('eol') ? { type: 'eol' } : eol,\n          mylexer.has('indent') ? { type: 'indent' } : indent,\n          'closure',\n        ],\n        postprocess: (data) => {\n          return {\n            label: 'state',\n            type: 'ifstate',\n            first_condition: data[2],\n            first_statement: [...data[5]],\n\n            has_middle_condition: false,\n            middle_statement: undefined,\n\n            has_last_statement: false,\n            last_statement: undefined,\n          };\n        },\n      },\n      {\n        name: 'if_state',\n        symbols: [\n          { literal: '만약' },\n          '_',\n          'condition',\n          mylexer.has('eol') ? { type: 'eol' } : eol,\n          mylexer.has('indent') ? { type: 'indent' } : indent,\n          'closure',\n          mylexer.has('dedent') ? { type: 'dedent' } : dedent,\n          { literal: '거짓' },\n          '_',\n          mylexer.has('eol') ? { type: 'eol' } : eol,\n          mylexer.has('indent') ? { type: 'indent' } : indent,\n          'closure',\n        ],\n        postprocess: (data) => {\n          return {\n            label: 'state',\n            type: 'ifstate',\n            first_condition: data[2],\n            first_statement: data[5],\n\n            has_middle_condition: false,\n            middle_statement: undefined,\n\n            has_last_statement: true,\n            last_statement: [...data[11]],\n          };\n        },\n      },\n      { name: 'if_state$ebnf$1', symbols: [] },\n      {\n        name: 'if_state$ebnf$1$subexpression$1',\n        symbols: [\n          { literal: '아니면' },\n          '_',\n          'condition',\n          mylexer.has('eol') ? { type: 'eol' } : eol,\n          mylexer.has('indent') ? { type: 'indent' } : indent,\n          'closure',\n          mylexer.has('dedent') ? { type: 'dedent' } : dedent,\n        ],\n      },\n      {\n        name: 'if_state$ebnf$1',\n        symbols: ['if_state$ebnf$1', 'if_state$ebnf$1$subexpression$1'],\n        postprocess: function arrpush(d) {\n          return d[0].concat([d[1]]);\n        },\n      },\n      {\n        name: 'if_state',\n        symbols: [\n          { literal: '만약' },\n          '_',\n          'condition',\n          mylexer.has('eol') ? { type: 'eol' } : eol,\n          mylexer.has('indent') ? { type: 'indent' } : indent,\n          'closure',\n          mylexer.has('dedent') ? { type: 'dedent' } : dedent,\n          'if_state$ebnf$1',\n          { literal: '아니면' },\n          '_',\n          'condition',\n          mylexer.has('eol') ? { type: 'eol' } : eol,\n          mylexer.has('indent') ? { type: 'indent' } : indent,\n          'closure',\n        ],\n        postprocess: (data) => {\n          return {\n            label: 'state',\n            type: 'ifstate',\n            first_condition: data[2],\n            first_statement: data[5],\n\n            has_middle_condition: true,\n            middle_condition: [...data[7].map((value) => value[2]), data[10]],\n            middle_statement: [...data[7].map((value) => value[5]), data[13]],\n\n            has_last_condition: false,\n            last_statement: undefined,\n          };\n        },\n      },\n      {\n        name: 'if_state$ebnf$2$subexpression$1',\n        symbols: [\n          { literal: '아니면' },\n          '_',\n          'condition',\n          mylexer.has('eol') ? { type: 'eol' } : eol,\n          mylexer.has('indent') ? { type: 'indent' } : indent,\n          'closure',\n          mylexer.has('dedent') ? { type: 'dedent' } : dedent,\n        ],\n      },\n      { name: 'if_state$ebnf$2', symbols: ['if_state$ebnf$2$subexpression$1'] },\n      {\n        name: 'if_state$ebnf$2$subexpression$2',\n        symbols: [\n          { literal: '아니면' },\n          '_',\n          'condition',\n          mylexer.has('eol') ? { type: 'eol' } : eol,\n          mylexer.has('indent') ? { type: 'indent' } : indent,\n          'closure',\n          mylexer.has('dedent') ? { type: 'dedent' } : dedent,\n        ],\n      },\n      {\n        name: 'if_state$ebnf$2',\n        symbols: ['if_state$ebnf$2', 'if_state$ebnf$2$subexpression$2'],\n        postprocess: function arrpush(d) {\n          return d[0].concat([d[1]]);\n        },\n      },\n      {\n        name: 'if_state',\n        symbols: [\n          { literal: '만약' },\n          '_',\n          'condition',\n          mylexer.has('eol') ? { type: 'eol' } : eol,\n          mylexer.has('indent') ? { type: 'indent' } : indent,\n          'closure',\n          mylexer.has('dedent') ? { type: 'dedent' } : dedent,\n          'if_state$ebnf$2',\n          { literal: '거짓' },\n          '_',\n          mylexer.has('eol') ? { type: 'eol' } : eol,\n          mylexer.has('indent') ? { type: 'indent' } : indent,\n          'closure',\n        ],\n        postprocess: (data) => {\n          return {\n            label: 'state',\n            type: 'ifstate',\n            first_condition: data[2],\n            first_statement: data[5],\n\n            has_middle_condition: true,\n            middle_condition: [...data[7].map((value) => value[2])],\n            middle_statement: [...data[7].map((value) => value[5])],\n\n            has_last_statement: true,\n            last_statement: [...data[12]],\n          };\n        },\n      },\n      {\n        name: 'condition',\n        symbols: [\n          'expr',\n          '_',\n          mylexer.has('operator') ? { type: 'operator' } : operator,\n          '_',\n          'expr',\n        ],\n        postprocess: (data) => {\n          return {\n            type: 'condition',\n            value: [data[0], data[2], data[4]],\n          };\n        },\n      },\n      {\n        name: 'arg_list',\n        symbols: ['expr'],\n        postprocess: (data) => {\n          return [data[0]];\n        },\n      },\n      {\n        name: 'arg_list',\n        symbols: ['arg_list', '__', 'expr'],\n        postprocess: (data) => {\n          return [...data[0], data[2]];\n        },\n      },\n      { name: 'array$ebnf$1', symbols: [] },\n      {\n        name: 'array$ebnf$1$subexpression$1',\n        symbols: [{ literal: ',' }, '_', 'expr'],\n      },\n      {\n        name: 'array$ebnf$1',\n        symbols: ['array$ebnf$1', 'array$ebnf$1$subexpression$1'],\n        postprocess: function arrpush(d) {\n          return d[0].concat([d[1]]);\n        },\n      },\n      {\n        name: 'array',\n        symbols: [\n          { literal: '[' },\n          '_',\n          'expr',\n          '_',\n          'array$ebnf$1',\n          '_',\n          { literal: ']' },\n        ],\n        postprocess: (data) => {\n          return [data[2], ...data[4].map((v) => v[2])];\n        },\n      },\n      {\n        name: 'expr',\n        symbols: [mylexer.has('string') ? { type: 'string' } : string],\n        postprocess: id,\n      },\n      {\n        name: 'expr',\n        symbols: [\n          mylexer.has('identifier') ? { type: 'identifier' } : identifier,\n        ],\n        postprocess: id,\n      },\n      { name: 'expr', symbols: ['fun_call'], postprocess: id },\n      { name: 'expr', symbols: ['AS'], postprocess: id },\n      {\n        name: 'for_state',\n        symbols: [\n          { literal: '반복' },\n          '__',\n          'expr',\n          '_',\n          mylexer.has('iterator') ? { type: 'iterator' } : iterator,\n          '_',\n          'expr',\n          mylexer.has('eol') ? { type: 'eol' } : eol,\n          mylexer.has('indent') ? { type: 'indent' } : indent,\n          'closure',\n        ],\n        postprocess: (data) => {\n          return {\n            label: 'statement',\n            type: 'for_block',\n            a: data[2],\n            iterator: data[4],\n            b: data[6],\n            statement: data[9],\n          };\n        },\n      },\n      {\n        name: 'return',\n        symbols: [{ literal: '출력' }, '_', 'expr'],\n        postprocess: (d) => {\n          return { type: 'return', value: d[2] };\n        },\n      },\n      {\n        name: 'P',\n        symbols: [{ literal: '(' }, '_', 'AS', '_', { literal: ')' }],\n        postprocess: (d) => {\n          return d[2];\n        },\n      },\n      { name: 'P', symbols: ['number'], postprocess: id },\n      { name: 'MD', symbols: ['P'], postprocess: id },\n      {\n        name: 'MD',\n        symbols: ['MD', '_', { literal: '*' }, '_', 'P'],\n        postprocess: (d) => {\n          return [d[0], d[2], d[4]];\n        },\n      },\n      {\n        name: 'MD',\n        symbols: ['MD', '_', { literal: '/' }, '_', 'P'],\n        postprocess: (d) => {\n          return [d[0], d[2], d[4]];\n        },\n      },\n      { name: 'AS', symbols: ['MD'], postprocess: id },\n      {\n        name: 'AS',\n        symbols: ['AS', '_', { literal: '+' }, '_', 'MD'],\n        postprocess: (d) => {\n          return [d[0], d[2], d[4]];\n        },\n      },\n      {\n        name: 'AS',\n        symbols: ['AS', '_', { literal: '-' }, '_', 'MD'],\n        postprocess: (d) => {\n          return [d[0], d[2], d[4]];\n        },\n      },\n      {\n        name: 'cal',\n        symbols: [\n          mylexer.has('calculator') ? { type: 'calculator' } : calculator,\n        ],\n        postprocess: id,\n      },\n      {\n        name: 'number',\n        symbols: [mylexer.has('number') ? { type: 'number' } : number],\n        postprocess: id,\n      },\n      { name: 'number', symbols: ['float'], postprocess: id },\n      {\n        name: 'float',\n        symbols: [\n          mylexer.has('number') ? { type: 'number' } : number,\n          { literal: '.' },\n          mylexer.has('number') ? { type: 'number' } : number,\n        ],\n        postprocess: (d) => ({\n          label: 'atom',\n          type: 'float',\n          value: d[0] + d[1] + d[2],\n        }),\n      },\n      { name: '_$ebnf$1', symbols: [] },\n      {\n        name: '_$ebnf$1',\n        symbols: ['_$ebnf$1', mylexer.has('ws') ? { type: 'ws' } : ws],\n        postprocess: function arrpush(d) {\n          return d[0].concat([d[1]]);\n        },\n      },\n      { name: '_', symbols: ['_$ebnf$1'] },\n      { name: '__$ebnf$1', symbols: [mylexer.has('ws') ? { type: 'ws' } : ws] },\n      {\n        name: '__$ebnf$1',\n        symbols: ['__$ebnf$1', mylexer.has('ws') ? { type: 'ws' } : ws],\n        postprocess: function arrpush(d) {\n          return d[0].concat([d[1]]);\n        },\n      },\n      { name: '__', symbols: ['__$ebnf$1'] },\n      { name: '_m$ebnf$1', symbols: [] },\n      {\n        name: '_m$ebnf$1',\n        symbols: ['_m$ebnf$1', mylexer.has('ws') ? { type: 'ws' } : ws],\n        postprocess: function arrpush(d) {\n          return d[0].concat([d[1]]);\n        },\n      },\n      {\n        name: '_m$subexpression$1$ebnf$1',\n        symbols: [mylexer.has('eol') ? { type: 'eol' } : eol],\n      },\n      {\n        name: '_m$subexpression$1$ebnf$1',\n        symbols: [\n          '_m$subexpression$1$ebnf$1',\n          mylexer.has('eol') ? { type: 'eol' } : eol,\n        ],\n        postprocess: function arrpush(d) {\n          return d[0].concat([d[1]]);\n        },\n      },\n      { name: '_m$subexpression$1', symbols: ['_m$subexpression$1$ebnf$1'] },\n      {\n        name: '_m$subexpression$1',\n        symbols: [mylexer.has('dedent') ? { type: 'dedent' } : dedent],\n      },\n      { name: '_m', symbols: ['_m$ebnf$1', '_m$subexpression$1'] },\n    ],\n    ParserStart: 'statements',\n  };\n  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n    module.exports = grammar;\n  } else {\n    window.grammar = grammar;\n  }\n})();\nexport default grammar","import React, { useState } from 'react';\nimport 'codemirror/lib/codemirror.css';\nimport 'codemirror/theme/material.css';\nimport 'codemirror/mode/xml/xml';\nimport 'codemirror/mode/javascript/javascript';\nimport 'codemirror/mode/css/css';\nimport { Controlled as ControlledEditor } from 'react-codemirror2';\n\nfunction Editor(props) {\n  const { language, value, onChange } = props;\n  function handlechange(editor, data, value) {\n    onChange(value);\n  }\n  return (\n    <>\n      <div className=\"editor_container\">\n        <ControlledEditor\n          className=\"editor\"\n          onBeforeChange={handlechange}\n          value={value}\n          options={{\n            lint: true,\n            lineNumbers: true,\n            mode: language,\n            lineWrapping: true,\n            theme: 'material',\n          }}\n        />\n      </div>\n    </>\n  );\n}\n\nexport default Editor;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n","const IndentifyLexer = require('@shieldsbetter/nearley-indentify');\n\nconst indentifiedLexer = new IndentifyLexer(mooLexer());\n\nfunction mooLexer() {\n  return require('moo').compile({\n    ws: /[ \\t]+/,\n    nl: { match: /\\n/, lineBreaks: true },\n    comment: /\\/\\/.*?$/,\n    number: /0|[1-9][0-9]*/,\n    string: /\"(?:\\\\[\"\\\\]|[^\\n\"\\\\])*\"/,\n    iterator: '<-',\n    operator: ['==', '>=', '<=', '!=', '>', '<', '.', ','],\n    calculator: ['+', '-', '*', '/', '++', '--'],\n    lparen: '(',\n    rparen: ')',\n    lbracke: '[',\n    rbracke: ']',\n    lbrace: '{',\n    rbrace: '}',\n    identifier: /[a-zA-Z가-힣][a-zA-Z가-힣_0-9]*/,\n    fatarrow: '=>',\n    assign: '=',\n    keyword: ['만약', '반복'],\n  });\n}\n\n/* indentifiedLexer.reset(`\n    Hello World\n        Heres some\n        indentation\n    And dedentation\n`);\n\nlet token = indentifiedLexer.next();\nwhile (token) {\n  console.log({ type: token.type, value: token.value });\n\n  token = indentifiedLexer.next();\n} */\n\nmodule.exports = indentifiedLexer;\n\n/* async function main() {\n  //prettier-ignore\n  const code = (await fs.readFile(\"ex2.small\")).toString();\n  lexer.reset(code);\n  while (true) {\n    const token = lexer.next();\n    if (!token) {\n      break;\n    }\n    console.log(token);\n  }\n}\n\nmain().catch((err) => console.log(err.stack)); */\n"],"sourceRoot":""}